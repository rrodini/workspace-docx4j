# for General-2023.txt (General election of Nov 7, 2023 w/ Judge Retentions)
#https://stackoverflow.com/questions/6696770/reading-java-property-groups-from-a-file
# ContestGen.properties - Probably the most important and most difficult properties
# file to construct and maintain.  Most of the properties are Regular Expressions (regexes)
# that drive the parsing of the Voter Services text into precinct ballots and contest files.

# common section
# environment (TEST, INTEGRATION, PRODUCTION)
environment=PRODUCTION

# ElectionType (see ElectionType enum. Primary, General)
election.type=Primary

# Endorsed party (see Party enum. (case-sensitive))
endorsed.party=Democratic

# Chester County values
#

# ContetGen: CONTESTS,BALLOTS,BOTH (default)
chester.contestgen.output=BOTH
# TRUE=>ballot text files generated like "350_MALVERN.txt" / FALSE => like "municipal-47.txt"
chester.precinctNoName.fileName=true
# ContestGen
chester.electionNameRegex=(?mi)^COUNTY OF CHESTER, COMMONWEALTH OF PENNSYLVANIA$\n(?<electionname>(.*\n){2})
chester.muniNameRepeatCount=1
chester.muniNameRegex=(?m)^Chester County\nBoard of Elections\nDEM (?<id>\\d+) (?<name>.*)\n

# BallotNamer
# DO NOT USE. Next two regexes were obsoleted by v1.7.0.
#chester.ballotnamer.ballot.title=Board of Elections
#chester.ballotnamer.ballot.heading.format=(?m)^%ballot title%$\nDEM (?<id>\\d+)[\\s]*(?<name>.*)\n

# ContestGen
# DO NOT USE. Next three regexes were obsoleted by v1.7.0. 
#chester.muniTextPageCount=2
#chester.muniTextPage1Regex=(?m)((.*\n)*^(by regular ballot.\nVote Both Sides|by regular ballot.$)\n)(?<page>((.*)\n)*?)^(Review|Vote Both Sides)$
#chester.muniTextPage2Regex=(?m)(^Vote Both Sides$\n)(.*\n)*(^Vote Both Sides$\n)(?<page>((.*)\n)*)^(Review)$
# NEW - Used by v1.7.0+
chester.pageBreakRegex=(?m)Vote Both Sides
chester.onePageRegex=(?m)((.*\n)*^(by regular ballot.\n))(?<page>((.*)\n)*)
chester.twoPage1Regex=(?m)((.*\n)*^(Vote Both Sides\n))(?<page>((.*)\n)*)^Vote Both Sides$
chester.twoPage2Regex=(?m)(^Vote Both Sides$\n)(.*\n)*(^Vote Both Sides$\n)(?<page>((.*)\n)*)^Review$

# ContestGen (see ContestExtractor) 
chester.contest.format.1=^(?<name>(.*\n){1,3})(?<instructions>^Vote.*)\n(?<candidates>((.*\n){1})*?)^Write-in$
chester.contest.format.2=^(?<name>(.*\n){1,3})(?<term>^(\\d Year |Unexpired ).*)\n(?<instructions>^Vote.*)\n(?<candidates>((.*\n){1})*?)^Write-in$
chester.contest.format.3=^(?<name>(.*\n){1,3})(?<region>^Region [A-Z].*)\n(?<term>^(\\d |Unexpired ).*)\n(?<instructions>^Vote.*)\n(?<candidates>((.*\n){1})*?)^Write-in$
chester.contest.format.4=^(?<name>(.*\n){1,3})(?<instructions>^Vote(.*\n)*?Vote for ONE)\n(?<candidates>((.*\n){1})*?)^Write-in$
# Used by ContestGen only.
# Referendum question.
chester.referendum.format=^(?<question>((.*\n).*Referendum.*\n))(?<text>(.*\n)*?)^YES$\nNO$
# Retention question.
chester.retention.question.format=^(?<question>(?<office>.*Retention\nElection Question$)((.*)\n)*?^YES\nNO)
chester.retention.name.format=((.*)\n)*^Shall (?<name>(.*)?) be retained.*\n((.*)\n)*^YES\nNO

# BallotGen properties (see formatsText)
chester.ballotgen.contest.format.1=^%contest name%\\n(?<instructions>^Vote.*)\\n(?<candidates>((.*\\n){1})*?)^Write-in$
chester.ballotgen.contest.format.2=^%contest name%\\n(?<term>^(\\d Year |Unexpired ).*)\\n(?<instructions>^Vote.*)\\n(?<candidates>((.*\\n){1})*?)^Write-in$
chester.ballotgen.contest.format.3=^%contest name%\\n(?<region>^Region [A-Z].*)\\n(?<term>^(\\d |Unexpired ).*)\\n(?<instructions>^Vote.*)\\n(?<candidates>((.*\\n){1})*?)^Write-in$
chester.ballotgen.contest.format.4=^%contest name%\\n(?<instructions>^Vote(.*\\n)*?Vote for ONE)\\n(?<candidates>((.*\\n){1})*?)^Write-in$

chester.ballotgen.referendum.format=^%question%\\n(?<text>(.*\\n)*?)^YES$\nNO$
chester.ballotgen.retention.format=^%office name%\\n((^Shall %judge name% be retained(.*\\n)*?))^YES$\nNO$

# Write.in
chester.write.in=Write-in\n
#
# Bucks Count values
# TBD